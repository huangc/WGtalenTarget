#!/bin/bash
#PBS -m abe
#PBS -l nodes=1:ppn=20,vmem=20gb,walltime=1:00:00
#PBS -N WGtalen
#PBS -j oe

module add python
module add blat

# Aims: To investigate the Whole-Genome (WG) insertion/deletion (indel) profile of rice genomic samples under TALEN treatment.
# Author: Chun-Yuan Huang, Ph.D.
# Last Update: 2/22/2016

##-------------------------------------------
## Workflow description:
#1. WG paired TALEN binding sites prediction using TALE-NT2 targetter
#3. Extract sequences of iLoci that contain paired TALENs (pTALEN).
#4. Blat of sample contigs against pTALEN (pTALEN from #3, sample contigs were assembled according to TRegGA workflow).
#5. Generate filtered blat hits table (#4) for contigs that contain gaps whose total length larger than the defined size (4 bp).
#6. Generate the join table of iLoci that contain both pTALEN (#3) and indels (#5).
#7. Narrow down the #6 iLoci hits whose pTALEN (#3) is within the defined distance (100 bp) from the indel region (#5).
#8. Extract the blat alignemnts (#4) according to the #7 iLoci hits for final inspection.


cd $PBS_O_WORKDIR
source ./0SOURCE
cd ${run_DIR}

#0. Prerequisite files
# Deletion summary table: ${data_DIR}/Seq.t_Lg${GAP_MINSIZE}.table, generated from x2-WGindelT with the content:
# "Tname tGapStart tGapSize Samples" 
# TALEN RVD sequences: ${prereq_DIR}/pTALEN_*, generated from PREREQ.sh with the content: 
# '"rvdseq1" "rvdseq2"'

#-----
#1. Make TALE-NT2 prediction of paied-TALEN binding sites on REFSEQ
#
mkdir -p ptalen
cd ptalen
\rm pairedtalesf.sh
for p in ${PTALEN}
do
cp -s ${prereq_DIR}/${p} .
echo "
#!/usr/bin/bash
pairedtalesf \
        -m ${TPO_m} \
        -x ${TPO_x} \
        -n ${TPO_n} \
        -t ${TPO_t} \
        -o pairedtalesf.${p}-on-${REFSEQNAME} \
        ${prereq_DIR}/${REFSEQ} \
        "`cat ${p}`"
" >> pairedtalesf.sh
done
sh pairedtalesf.sh

##-----
#2. Rearrange columns of pTalen table and add ${PTALEN} for clarity.
# Sequence_Name(#1)  ${PTALEN} TAL_1(#2) TAL_2(#3) TAL_1_Score(#4) TAL_2_Score(#5) 
# TAL_1_Start(#6) TAL_2_Start(#7) Spacer_Length(#8) TAL_1_Target(#9) TAL_2_Target(#10).
# Change the TAL_Target such that "T TCCTGAAGAATTGATTCACTTC" becomes "TTCCTGAAGAATTGATTCACTTC"

cd ${run_DIR}/ptalen
\rm pairedtalesf.pTALENs-on-${REFSEQNAME}.txt
for p in ${PTALEN}
do
sed -r 's/\bT\s/T/g' pairedtalesf.${p}-on-${REFSEQNAME}.txt | \
awk -v Rvd=${p} '{ FS="\t"; OFS="\t"; print $1,$6,$7,$8,$9,$10,$2,$3,$4,$5,Rvd }' | \
tail -n+4 >> pairedtalesf.pTALENs-on-${REFSEQNAME}.txt
done

#3. Generate the join table that contain the "associated" pTALEN and indels, 
# which are defined as having their distance within ${PTALEN_INDEL} bp.
# Join the tables by Tname(#1), tGapStart(#2), tGapSize(#3)
#
cd ${run_DIR}/ptalen
ln -s ${data_DIR}/Seq.t_Lg${GAP_MINSIZE}.table .

\rm Seq.t_pTALENs-on-${REFSEQNAME}.assoct
len=`awk 'END { print NR }' Seq.t_Lg${GAP_MINSIZE}.table`
# Note that the first row is the header "Tname tGapStart tGapSize Samples"
for ((k=2; k<=$len; k++))
do
head -$k Seq.t_Lg${GAP_MINSIZE}.table | tail -1 > Trec
cut -d " " -f1 rec > Trec.Tname
cut -d " " -f2 rec > Trec.tGapStart
cut -d " " -f3 rec > Trec.tGapSize
cut -d " " -f4 rec > Trec.Samples

# This is to loop over the ptalen table for associated pTALEN site
row=`awk 'END { print NR }' pairedtalesf.pTALENs-on-${REFSEQNAME}.txt`
for ((m=1; m<=$row; m++))
do
cut -d "\t" -f1 Prec.SeqName
cut -d "\t" -f2 Prec.TAL_1_Start
cut -d "\t" -f3 Prec.TAL_2_Start
cut -d "\t" -f4 Prec.TAL_1_Target
cut -d "\t" -f5 Prec.TAL_2_Target
cut -d "\t" -f6 Prec.TAL_1
cut -d "\t" -f7 Prec.TAL_2
cut -d "\t" -f8 Prec.TAL_1_Score
cut -d "\t" -f9 Prec.TAL_2_Score
cut -d "\t" -f10 Prec.PTALEN

Tname=`cat Trec.Tname`
tGapStart=`cat Trec.tGapStart`
tGapSize=`cat Trec.tGapSize`
tGapEnd=`expr $tGapStart + $tGapSize`

Pname=`cat Prec.SeqName`
pTAL1Start=`cat Prec.TAL_1_Start`
pTAL2Start=`cat Prec.TAL_2_Start`
pTAL1Target=`cat Prec.TAL_1_Target`
pTAL2Target=`cat Prec.TAL_2_Target`
pTAL1Rvd=`cat Prec.TAL_1`
pTAL2Rvd=`cat Prec.TAL_2`
pTAL1Score=`cat Prec.TAL_1_Score`
pTAL2Score=`cat Prec.TAL_2_Score`
pTALEN=`cat Prec.PTALEN`

if [ ${Tname} == ${Pname} ]; then
    if [ ${pTAL1Start} < ${tGapStart} \& `exp ${tGapStart} - ${pTAL1Start}` < `exp ${PLEN} + ${PDEL}` ]; then
	echo "${Tname} ${tGapStart} ${tGapEnd} ${tGapSize} ${pTAL1Start} ${pTAL2Start} ${pTAL1Target} ${pTAL2Target}\
${pTAL1Rvd} ${pTAL2Rvd} ${pTAL1Score} ${pTAL2Score} ${pTALEN}" >> Seq.t_pTALENs-on-${REFSEQNAME}.assoct
    elif [ ${pTAL1Start} >= ${tGapStart} \& ${pTAL1Start} < ${tGapEnd} ]; then
	echo "${Tname} ${tGapStart} ${tGapEnd} ${tGapSize} ${pTAL1Start} ${pTAL2Start} ${pTAL1Target} ${pTAL2Target}\
${pTAL1Rvd} ${pTAL2Rvd} ${pTAL1Score} ${pTAL2Score} ${pTALEN}" >> Seq.t_pTALENs-on-${REFSEQNAME}.assoct
    elif [ ${pTAL1Start} > ${tGapEnd} \& `exp  ${pTAL1Start} - ${tGapEnd}` < ${PDEL} ]; then
	echo "${Tname} ${tGapStart} ${tGapEnd} ${tGapSize} ${pTAL1Start} ${pTAL2Start} ${pTAL1Target} ${pTAL2Target}\
${pTAL1Rvd} ${pTAL2Rvd} ${pTAL1Score} ${pTAL2Score} ${pTALEN}" >> Seq.t_pTALENs-on-${REFSEQNAME}.assoct
    fi
fi





awk -v Plen=${PTALEN_LEN} -v Pdel=${PTALEN_INDEL} '{ OFS="\t"; if ($pTalen1<$GapStart && ($GapStart-$pTalen1)<(Plen+Pdel)) print $0 ; \
else if ($pTalen1>=$GapStart && $pTalen1<$GapEnd) print $0; else if ($pTalen1>=$GapEnd && ($pTalen1-$GapEnd)<Pdel) print $0 }' rec.overlap >> blat.${DB_PTALEN}.${QUERYNAME}.psl.awk.join.overlap


done


#-----
#8. Extract the blat alignemnts (#4) according to the #7 iLoci hits for final inspection.
#
# Note that a ilocus that contains indel at a low complexity region may not be considered a good candidate.
#
mkdir -p ${blat_gap_ptalen_overlap_DIR}
cd ${blat_gap_ptalen_overlap_DIR}
for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
\rm ${DB_PTALEN}.${QUERYNAME}.alignment.report
\cp ${blat_gap_ptalen_DIR}/blat.${DB_PTALEN}.${QUERYNAME}.psl.awk.join.1.overlap.1 ${DB_PTALEN}.${QUERYNAME}.indel.overlap
\cp ${blat_gap_ptalen_DIR}/blat.${DB_PTALEN}.${QUERYNAME}.psl.awk.join.1.overlap.3 ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader

len=`awk 'END { print NR }' ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader`

for ((k=1; k<=$len; k++))
do
query=`head -$k ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader | tail -1 | cut -d " " -f 1`
ilocus=`head -$k ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader | tail -1 | cut -d " " -f 2`
blastdbcmd -db ${prereq_DIR}/DB_${i}_contig -entry "lcl|${query}" -dbtype nucl -outfmt "%f" -out ${i}-${query}.fa
sed -i -e "s/>lcl|/>/" ${i}-${query}.fa
blastdbcmd -db ${ptalen_DIR}/${DB_PTALEN} -entry ${ilocus} -dbtype nucl -outfmt "%f" -out ${ilocus}.fa
sed -i -e "s/>lcl|/>/" ${ilocus}.fa

blat -t=dna -q=dna -out=psl -minIdentity=${PERC_IDENTITY} -minScore=${MIN_SCORE} ${ilocus}.fa ${i}-${query}.fa \
blat.${i}-${query}-on-${ilocus}.psl
blat -t=dna -q=dna -out=blast -minIdentity=${PERC_IDENTITY} -minScore=${MIN_SCORE} ${ilocus}.fa ${i}-${query}.fa \
blat.${i}-${query}-on-${ilocus}.blast
pslPretty blat.${i}-${query}-on-${ilocus}.psl ${ilocus}.fa ${i}-${query}.fa blat.${i}-${query}-on-${ilocus}.psl.pretty
pslPretty -long blat.${i}-${query}-on-${ilocus}.psl ${ilocus}.fa ${i}-${query}.fa blat.${i}-${query}-on-${ilocus}.psl.pretty.long

done
done

more *${SEQNAME}.indel.overlap > ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap
echo "
# The iloci from samples that contain overlapping indel and pTALEN
" | cat - ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap > tmp && \mv tmp ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap


#-----
#9. Manually inspect the iloci from samples for containing overlapping paired-TALEN and indel.
#---
# THIS SECTION REQUIRES MANUAL INSPECTION
# Cases whose indels are likely resulted from low complexicity reading/sequencing error, or whose \
# indels are too far away and not overlapping with the paired-talen are dropped out in this step.
#---
#
cd ${blat_gap_ptalen_overlap_DIR}
mkdir -p ${blat_gap_ptalen_overlap_inspected_DIR}
\cp -r ${DB_PTALEN}.*.contig.indel.overlap ${blat_gap_ptalen_overlap_inspected_DIR}
\cp -r blat.*.psl.pretty.long ${blat_gap_ptalen_overlap_inspected_DIR}
# Use ${DB_PTALEN}.${QUERYNAME}.indel.overlap as a guide to identify and annotate\
# (with xxxxx marks) the paired-TALEN EBE on the \
# blat.${i}-${query}-on-${ilocus}.psl.pretty.long. Renname the file to -YES for positive, \
# -NO for negative, and -ND for not able to determine.
# Update ${DB_PTALEN}.${QUERYNAME}.indel.overlap to include only the positives
# generate ${DB_PTALEN}.${QUERYNAME}.indel.overlap with no header
cd ${blat_gap_ptalen_overlap_inspected_DIR}
mkdir -p NO/
\mv blat.*.psl.pretty.long-N* NO/

for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
tail -n+2 ${DB_PTALEN}.${QUERYNAME}.indel.overlap > ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader
\rm ${DB_PTALEN}.${QUERYNAME}.alignment.report
len=`awk 'END { print NR }' ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader`
for ((k=1; k<=$len; k++))
do
query=`head -$k ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader | tail -1 | cut -d " " -f 1`
ilocus=`head -$k ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader | tail -1 | cut -d " " -f 2`
echo "
##-------------------------------------------------
##Report for blat alignment of ${i} query ${query} against target ${ilocus}
# The paired TALEN EBE sites are marked with "xxxxx"
# Only alignment region of surrounding 10 lines from the pTALEN site is shown here for quick survey purpose.
# See original file blat.${i}-${query}-on-${ilocus}.psl.pretty.long-YES for full record.
#
" >> ${DB_PTALEN}.${QUERYNAME}.alignment.report
head -1 blat.${i}-${query}-on-${ilocus}.psl.pretty.long-YES >> ${DB_PTALEN}.${QUERYNAME}.alignment.report
echo "
#-----Gap Region-----
" >> ${DB_PTALEN}.${QUERYNAME}.alignment.report
cat blat.${i}-${query}-on-${ilocus}.psl.pretty.long-YES | grep -B 10 -A 10 -E "xx" >> ${DB_PTALEN}.${QUERYNAME}.alignment.report

done
done

more *.${SEQNAME}*.alignment.report > ${DB_PTALEN}.${SEQNAME}.ALLSample.alignment.report
more *${SEQNAME}.indel.overlap > ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap
echo "
# The iloci from samples that contain overlapping indel and pTALEN
" | cat - ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap > tmp && \mv tmp ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap

echo "
##-------------------------------------------------
## The alignemnts of filtered blat hits for query sequences against reference that contain one or more indels
# with total indel gap length larger than 4 bp, and also contain the overlapping talesfpaired predicted pTalen EBE (pTalen)
# Original file at:
${blat_gap_ptalen_overlap_DIR}/${DB_PTALEN}.${SEQNAME}.ALLSample.alignment.report
" >> ${report_DIR}/${REPORT}

cat ${DB_PTALEN}.${SEQNAME}.ALLSample.alignment.report >> ${report_DIR}/${REPORT}

#-----
#10. Report
#
mkdir -p ${report_DIR}
cd ${report_DIR}

mkdir -p ${report_DIR}/off_targets
\cp ${blat_gap_ptalen_overlap_inspected_DIR}/${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap .
\cp -r ${blat_gap_ptalen_overlap_inspected_DIR}/blat.*-YES ${report_DIR}/off_targets

mkdir -p ${report_DIR}/all_targets
\cp ${suppl_DIR}/0README-suppl .
\cp -r ${suppl_DIR}/gap/catalog/list/iloci.table.h* ${report_DIR}/all_targets
\cp -r ${suppl_DIR}/gap/catalog/list/iloci.table.H* ${report_DIR}/all_targets

mkdir -p ${report_DIR}/all_targets/YB12345678
\cp -r ${suppl_DIR}/gap/catalog/blat/YB12345678/blat.*.pretty.short ${report_DIR}/all_targets/YB12345678

mkdir -p ${report_DIR}/all_targets/YB1v2345678
\cp -r ${suppl_DIR}/gap/catalog/blat/YB1v2345678/blat.*.pretty.short ${report_DIR}/all_targets/YB1v2345678


#-----
#DONE
#-----

