#!/bin/bash
#PBS -m abe
#PBS -l nodes=1:ppn=20,vmem=20gb,walltime=1:00:00
#PBS -N WGtalen
#PBS -j oe

module add python
module add blat

# Aims: To investigate the Whole-Genome (WG) insertion/deletion (indel) profile of rice genomic samples under TALEN treatment.
# Author: Chun-Yuan Huang, Ph.D.
# Last Update: 2/26/2016

##-------------------------------------------
## Workflow description:
#1. WG paired TALEN binding sites prediction using TALE-NT2 targetter
#3. Extract sequences of iLoci that contain paired TALENs (pTALEN).
#4. Blat of sample contigs against pTALEN (pTALEN from #3, sample contigs were assembled according to TRegGA workflow).
#5. Generate filtered blat hits table (#4) for contigs that contain gaps whose total length larger than the defined size (4 bp).
#6. Generate the join table of iLoci that contain both pTALEN (#3) and indels (#5).
#7. Narrow down the #6 iLoci hits whose pTALEN (#3) is within the defined distance (100 bp) from the indel region (#5).
#8. Extract the blat alignemnts (#4) according to the #7 iLoci hits for final inspection.


cd $PBS_O_WORKDIR
source ./0SOURCE
cd ${run_DIR}

#0. Prerequisite files
# Deletion summary table: ${data_DIR}/Seq.t_Lg${GAP_MINSIZE}.table, generated from x2-WGindelT with the content:
# "Tname tGapStart tGapSize Samples" 
# TALEN RVD sequences: ${prereq_DIR}/pTALEN_*, generated from PREREQ.sh with the content: 
# '"rvdseq1" "rvdseq2"'

#-----
#1. Make TALE-NT2 prediction of paied-TALEN binding sites on REFSEQ
#
mkdir -p ptalen
cd ptalen
\rm pairedtalesf.sh
for p in ${PTALEN}
do
\cp -r ${prereq_DIR}/${p} .
echo "
#!/usr/bin/bash
pairedtalesf \
        -m ${TPO_m} \
        -x ${TPO_x} \
        -n ${TPO_n} \
        -t ${TPO_t} \
        -o pairedtalesf.${p}-on-${REFSEQNAME} \
        ${prereq_DIR}/${REFSEQ} \
        "`cat ${p}`"
" >> pairedtalesf.sh
done
sh pairedtalesf.sh

##-----
#2. Rearrange columns of pTalen table and add ${PTALEN} for clarity.
# Sequence_Name(#1)  ${PTALEN} TAL_1(#2) TAL_2(#3) TAL_1_Score(#4) TAL_2_Score(#5) 
# TAL_1_Start(#6) TAL_2_Start(#7) Spacer_Length(#8) TAL_1_Target(#9) TAL_2_Target(#10).
# Change the TAL_Target such that "T TCCTGAAGAATTGATTCACTTC" becomes "TTCCTGAAGAATTGATTCACTTC"

cd ${run_DIR}/ptalen
\rm pairedtalesf.pTALENs-on-${REFSEQNAME}.txt
for p in ${PTALEN}
do
sed -r 's/\bT\s/T/g' pairedtalesf.${p}-on-${REFSEQNAME}.txt | \
awk -v Rvd=${p} '{ FS="\t"; OFS="\t"; print $1,$6,$7,$8,$9,$10,$2,$3,$4,$5,Rvd }' | \
tail -n+4 >> pairedtalesf.pTALENs-on-${REFSEQNAME}.txt
done

#3. Generate the join table that contain the "associated" pTALEN and indels, 
# where "associated" is defined as having their distance within ${PDEL} bp.
# Join the tables by Tname(#1), tGapStart(#2), tGapSize(#3)
#
cd ${run_DIR}/ptalen
\cp ${data_DIR}/Seq.t_onQ_Lg${GAP_MINSIZE}.table Seq.t_Lg${GAP_MINSIZE}.table

\rm Seq.t_pTALENs-on-${REFSEQNAME}.out
\rm Seq.t_pTALENs-on-${REFSEQNAME}.err
len=`awk 'END { print NR }' Seq.t_onQ_Lg${GAP_MINSIZE}.table`
# Note that the first row is the header 
# "Tname tGapStart tGapSize Qname qGapStart qGapSize Samples"

for ((k=2; k<=$len; k++))
do
head -$k Seq.t_Lg${GAP_MINSIZE}.table | tail -1 > Trec
cut -d " " -f1 Trec > Trec.Tname
cut -d " " -f2 Trec > Trec.tGapStart
cut -d " " -f3 Trec > Trec.tGapSize
cut -d " " -f4 Trec > Trec.Qname
cut -d " " -f5 Trec > Trec.qGapStart
cut -d " " -f6 Trec > Trec.qGapSize
cut -d " " -f7 Trec > Trec.Samples

# Now loop over the ptalen table for associated pTALEN site
row=`awk 'END { print NR }' pairedtalesf.pTALENs-on-${REFSEQNAME}.txt`
for ((m=4; m<=$row; m++))
do
head -$m pairedtalesf.pTALENs-on-${REFSEQNAME}.txt | tail -1 > Prec
cut -f1 Prec > Prec.SeqName
cut -f2 Prec > Prec.TAL_1_Start
cut -f3 Prec > Prec.TAL_2_Start
cut -f4 Prec > Prec.Spacer_Length
cut -f5 Prec > Prec.TAL_1_Target
cut -f6 Prec > Prec.TAL_2_Target
cut -f7 Prec > Prec.TAL_1
cut -f8 Prec > Prec.TAL_2
cut -f9 Prec > Prec.TAL_1_Score
cut -f10 Prec > Prec.TAL_2_Score
cut -f11 Prec > Prec.PTALEN

Tname=`cat Trec.Tname`
tGapStart=`cat Trec.tGapStart`
tGapSize=`cat Trec.tGapSize`
tGapEnd=`expr $tGapStart + $tGapSize`
Qname=`cat Trec.Qname`
qGapStart=`cat Trec.qGapStart`
qGapSize=`cat Trec.qGapSize`
qGapEnd=`expr $qGapStart + $qGapSize`

Pname=`cat Prec.SeqName`
pTAL1Start=`cat Prec.TAL_1_Start`
pTAL2Start=`cat Prec.TAL_2_Start`
pSpacerLen=`cat Prec.Spacer_Length`
pTAL1Target=`cat Prec.TAL_1_Target`
pTAL2Target=`cat Prec.TAL_2_Target`
pTAL1Rvd=`cat Prec.TAL_1`
pTAL2Rvd=`cat Prec.TAL_2`
pTAL1Score=`cat Prec.TAL_1_Score`
pTAL2Score=`cat Prec.TAL_2_Score`
pTALEN=`cat Prec.PTALEN`

if [[ ${Tname} = ${Pname} ]]; then
    if (( ${pTAL1Start} < ${tGapStart} && `expr ${tGapStart} - ${pTAL1Start}` < `expr ${PLEN} + ${PDEL}` )); then
	echo "${Tname} ${tGapStart} ${tGapSize} ${tGapEnd} ${Qname} ${qGapStart} ${qGapSize} ${qGapEnd}\
 ${pTAL1Start} ${pSpacerLen} ${pTAL2Start} ${pTAL1Target} ${pTAL2Target}\
 ${pTAL1Rvd} ${pTAL2Rvd} ${pTAL1Score} ${pTAL2Score} ${pTALEN}" >> Seq.t_pTALENs-on-${REFSEQNAME}.out
    elif (( ${pTAL1Start} >= ${tGapStart} && ${pTAL1Start} < ${tGapEnd} )); then
        echo "${Tname} ${tGapStart} ${tGapSize} ${tGapEnd} ${Qname} ${qGapStart} ${qGapSize} ${qGapEnd}\
 ${pTAL1Start} ${pSpacerLen} ${pTAL2Start} ${pTAL1Target} ${pTAL2Target}\
 ${pTAL1Rvd} ${pTAL2Rvd} ${pTAL1Score} ${pTAL2Score} ${pTALEN}" >> Seq.t_pTALENs-on-${REFSEQNAME}.out
    elif (( ${pTAL1Start} > ${tGapEnd} && `expr  ${pTAL1Start} - ${tGapEnd}` < ${PDEL} )); then
        echo "${Tname} ${tGapStart} ${tGapSize} ${tGapEnd} ${Qname} ${qGapStart} ${qGapSize} ${qGapEnd}\
 ${pTAL1Start} ${pSpacerLen} ${pTAL2Start} ${pTAL1Target} ${pTAL2Target}\
 ${pTAL1Rvd} ${pTAL2Rvd} ${pTAL1Score} ${pTAL2Score} ${pTALEN}" >> Seq.t_pTALENs-on-${REFSEQNAME}.out
    else
	echo "Deletion at ${Tname}-${tGapStart}-${tGapEnd} does not match pTALEN at\
 ${Pname}-${pTAL1Start}-${pTAL2Start}" >> Seq.t_pTALENs-on-${REFSEQNAME}.err
    fi
fi

done
done

echo "Tname tGapStart tGapSize tGapEnd Qname qGapStart qGapSize qGapEnd pTAL1Start pSpacerLen pTAL2Start\
 pTAL1Target pTAL2Target pTAL1Rvd pTAL2Rvd pTAL1Score pTAL2Score pTALEN" |\
 cat - Seq.t_pTALENs-on-${REFSEQNAME}.out > Seq.t_pTALENs-on-${REFSEQNAME}.OUT


#-----
#4. Retrieve the blat alignemnts according to the associated pTALEN-Del table 
#
# Note that a deletion at low complexity region may not be considered a good pTALEN target candidate.
#
cd ${run_DIR}
mkdir blat_at_pTALENdel
cd blat_at_pTALENdel
\cp ${run_DIR}/ptalen/Seq.t_pTALENs-on-${REFSEQNAME}.out .
\cp ${run_DIR}/ptalen/Seq.t_pTALENs-on-${REFSEQNAME}.OUT .

for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
\rm ${DB_PTALEN}.${QUERYNAME}.alignment.report
\cp ${run_DIR}/ptalen/Seq.t_pTALENs-on-${REFSEQNAME}.out .
\cp ${run_DIR}/ptalen/Seq.t_pTALENs-on-${REFSEQNAME}.OUT .
\rm Seq.t_pTALEN_GapBorder${GAP_BORDER}_${i}.fasta
\rm Seq.q_pTALEN_GapBorder${GAP_BORDER}_${i}.fasta
len=`awk 'END { print NR }' Seq.t_pTALENs-on-${REFSEQNAME}.out`

for ((k=1; k<=$len; k++))
do
head -$k Seq.t_pTALENs-on-${REFSEQNAME}.out | tail -1 > rec
cut -d " " -f1 Trec > Trec.Tname
cut -d " " -f2 Trec > Trec.tGapStart
cut -d " " -f4 Trec > Trec.tGapEnd
cut -d " " -f5 Trec > Trec.Qname
cut -d " " -f6 Trec > Trec.qGapStart
cut -d " " -f8 Trec > Trec.qGapEnd

Tname=`cat Trec.Tname`
tGapStart=`cat Trec.tGapStart`
tGapEnd=`cat Trec.tGapEnd`
Qname=`cat Trec.Qname`
qGapStart=`cat Trec.qGapStart`
qGapEnd=`cat Trec.qGapEnd`

python ${bin_DIR}/getTarget.py ${prereq_DIR}/${Tname}.fa ${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}\
 `expr ${tGapStart} - ${GAP_BORDER}` `expr ${tGapEnd} + ${GAP_BORDER}`
sed -i "s/^>${Tname}/>${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}/" ${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}.fasta
cat ${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}.fasta >> Seq.t_pTALEN_GapBorder${GAP_BORDER}_${i}.fasta

blastdbcmd -db ${prereq_DIR}/DB_${i}_contig -entry "lcl|${Qname}" -dbtype nucl -outfmt "%f" -out ${i}-${Qname}.fa
sed -i -e "s/>lcl|/>/" ${i}-${Qname}.fa
python ${bin_DIR}/getTarget.py ${i}-${Qname}.fa ${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}\
 `expr ${qGapStart} - ${GAP_BORDER}` `expr ${qGapEnd} + ${GAP_BORDER}`
sed -i "s/^>${Qname}/>${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}/" ${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}.fasta
cat ${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}.fasta >> Seq.q_pTALEN_GapBorder${GAP_BORDER}_${i}.fasta

blat -t=dna -q=dna -out=psl -minIdentity=${PERC_IDENTITY} -minScore=${MIN_SCORE}\
 ${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}.fasta\
 ${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}.fasta\
 blat.${i}.${Qname}-on-${Tname}.${tGapStart}.${tGapEnd}.psl
pslPretty blat.${i}.${Qname}-on-${Tname}.${tGapStart}.${tGapEnd}.psl\
 ${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}.fasta\
 ${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}.fasta\
 blat.${i}.${Qname}-on-${Tname}.${tGapStart}.${tGapEnd}.psl.pretty
pslPretty -long blat.${i}.${Qname}-on-${Tname}.${tGapStart}.${tGapEnd}.psl\
 ${i}-${Tname}_GapBorder${GAP_BORDER}_${tGapStart}_${tGapEnd}.fasta\
 ${i}-${Qname}_GapBorder${GAP_BORDER}_${qGapStart}_${qGapEnd}.fasta\
 blat.${i}.${Qname}-on-${Tname}.${tGapStart}.${tGapEnd}.psl.pretty.long

done
done

more *${SEQNAME}.indel.overlap > ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap
echo "
# The iloci from samples that contain overlapping indel and pTALEN
" | cat - ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap > tmp && \mv tmp ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap


#-----
#9. Manually inspect the iloci from samples for containing overlapping paired-TALEN and indel.
#---
# THIS SECTION REQUIRES MANUAL INSPECTION
# Cases whose indels are likely resulted from low complexicity reading/sequencing error, or whose \
# indels are too far away and not overlapping with the paired-talen are dropped out in this step.
#---
#
cd ${blat_gap_ptalen_overlap_DIR}
mkdir -p ${blat_gap_ptalen_overlap_inspected_DIR}
\cp -r ${DB_PTALEN}.*.contig.indel.overlap ${blat_gap_ptalen_overlap_inspected_DIR}
\cp -r blat.*.psl.pretty.long ${blat_gap_ptalen_overlap_inspected_DIR}
# Use ${DB_PTALEN}.${QUERYNAME}.indel.overlap as a guide to identify and annotate\
# (with xxxxx marks) the paired-TALEN EBE on the \
# blat.${i}-${query}-on-${ilocus}.psl.pretty.long. Renname the file to -YES for positive, \
# -NO for negative, and -ND for not able to determine.
# Update ${DB_PTALEN}.${QUERYNAME}.indel.overlap to include only the positives
# generate ${DB_PTALEN}.${QUERYNAME}.indel.overlap with no header
cd ${blat_gap_ptalen_overlap_inspected_DIR}
mkdir -p NO/
\mv blat.*.psl.pretty.long-N* NO/

for i in ${SAMPLE}
do
QUERY=${i}-${SEQ}
QUERYNAME=${i}.${SEQNAME}
tail -n+2 ${DB_PTALEN}.${QUERYNAME}.indel.overlap > ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader
\rm ${DB_PTALEN}.${QUERYNAME}.alignment.report
len=`awk 'END { print NR }' ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader`
for ((k=1; k<=$len; k++))
do
query=`head -$k ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader | tail -1 | cut -d " " -f 1`
ilocus=`head -$k ${DB_PTALEN}.${QUERYNAME}.indel.overlap.nHeader | tail -1 | cut -d " " -f 2`
echo "
##-------------------------------------------------
##Report for blat alignment of ${i} query ${query} against target ${ilocus}
# The paired TALEN EBE sites are marked with "xxxxx"
# Only alignment region of surrounding 10 lines from the pTALEN site is shown here for quick survey purpose.
# See original file blat.${i}-${query}-on-${ilocus}.psl.pretty.long-YES for full record.
#
" >> ${DB_PTALEN}.${QUERYNAME}.alignment.report
head -1 blat.${i}-${query}-on-${ilocus}.psl.pretty.long-YES >> ${DB_PTALEN}.${QUERYNAME}.alignment.report
echo "
#-----Gap Region-----
" >> ${DB_PTALEN}.${QUERYNAME}.alignment.report
cat blat.${i}-${query}-on-${ilocus}.psl.pretty.long-YES | grep -B 10 -A 10 -E "xx" >> ${DB_PTALEN}.${QUERYNAME}.alignment.report

done
done

more *.${SEQNAME}*.alignment.report > ${DB_PTALEN}.${SEQNAME}.ALLSample.alignment.report
more *${SEQNAME}.indel.overlap > ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap
echo "
# The iloci from samples that contain overlapping indel and pTALEN
" | cat - ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap > tmp && \mv tmp ${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap

echo "
##-------------------------------------------------
## The alignemnts of filtered blat hits for query sequences against reference that contain one or more indels
# with total indel gap length larger than 4 bp, and also contain the overlapping talesfpaired predicted pTalen EBE (pTalen)
# Original file at:
${blat_gap_ptalen_overlap_DIR}/${DB_PTALEN}.${SEQNAME}.ALLSample.alignment.report
" >> ${report_DIR}/${REPORT}

cat ${DB_PTALEN}.${SEQNAME}.ALLSample.alignment.report >> ${report_DIR}/${REPORT}

#-----
#10. Report
#
mkdir -p ${report_DIR}
cd ${report_DIR}

mkdir -p ${report_DIR}/off_targets
\cp ${blat_gap_ptalen_overlap_inspected_DIR}/${DB_PTALEN}.${SEQNAME}.AllSample.indel.overlap .
\cp -r ${blat_gap_ptalen_overlap_inspected_DIR}/blat.*-YES ${report_DIR}/off_targets

mkdir -p ${report_DIR}/all_targets
\cp ${suppl_DIR}/0README-suppl .
\cp -r ${suppl_DIR}/gap/catalog/list/iloci.table.h* ${report_DIR}/all_targets
\cp -r ${suppl_DIR}/gap/catalog/list/iloci.table.H* ${report_DIR}/all_targets

mkdir -p ${report_DIR}/all_targets/YB12345678
\cp -r ${suppl_DIR}/gap/catalog/blat/YB12345678/blat.*.pretty.short ${report_DIR}/all_targets/YB12345678

mkdir -p ${report_DIR}/all_targets/YB1v2345678
\cp -r ${suppl_DIR}/gap/catalog/blat/YB1v2345678/blat.*.pretty.short ${report_DIR}/all_targets/YB1v2345678


#-----
#DONE
#-----

